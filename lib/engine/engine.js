define(function(require, exports, module){
// Generated by CoffeeScript 1.3.1
var AiPlayer, BulletsStorage, Engine, LocalPlayer, Starfield, TrailsStorage, Universe,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

require('threejs_extensions');

Starfield = require('./starfield');

TrailsStorage = require('./trails/trails_storage');

BulletsStorage = require('./bullets/bullets_storage');

LocalPlayer = require('./players/local_player');

AiPlayer = require('./players/ai_player');

Engine = (function() {
  var CAMERA_Z, FAR, NEAR, VIEW_ANGLE;

  Engine.name = 'Engine';

  VIEW_ANGLE = 45;

  NEAR = 1;

  FAR = 1000;

  CAMERA_Z = 1000;

  Engine.prototype.disposed = false;

  Engine.prototype.models = ['models/ship_basic.js', 'models/command_centre.js', 'models/command_centre_inner.js', 'models/turret.js', 'models/turret_base.js', 'models/mass_driver.js'];

  function Engine(config) {
    this.config = config;
    this.container = this.config.container;
    this.setupRenderer();
    this.setupScene();
    this.load();
  }

  Engine.prototype.width = function() {
    return window.innerWidth;
  };

  Engine.prototype.height = function() {
    return window.innerHeight;
  };

  Engine.prototype.setupRenderer = function() {
    if (window.location.hash === "#slow") {
      this.container.className = 'double';
      this.renderer = new THREE.WebGLRenderer;
      this.renderer.setSize(this.width() / 2, this.height() / 2);
      this.renderer.sortObjects = false;
    } else {
      this.renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      this.renderer.setSize(this.width(), this.height());
    }
    this.renderer.setClearColorHex(0x080808, 1);
    this.container.appendChild(this.renderer.domElement);
    if (window.Stats) {
      this.stats = new Stats();
      this.stats.domElement.style.position = 'absolute';
      this.stats.domElement.style.top = '0px';
      return this.container.appendChild(this.stats.domElement);
    }
  };

  Engine.prototype.setupScene = function() {
    this.scene = new THREE.Scene();
    this.camera = new THREE.PerspectiveCamera(VIEW_ANGLE, this.width() / this.height(), NEAR, FAR);
    this.camera.position.set(0, 0, CAMERA_Z);
    this.scene.add(this.camera);
    this.scene.add(new THREE.AmbientLight(0x999999));
    this.light = new THREE.PointLight(0xffffff);
    return this.scene.add(this.light);
  };

  Engine.prototype.screen_range = function(depth) {
    var range_x, range_y;
    range_x = Math.tan(this.camera.fov * Math.PI / 180) * (this.camera.position.z - depth) * 2;
    range_y = range_x / this.camera.aspect;
    return [range_x, range_y];
  };

  Engine.prototype.camera_x_min = function(range_x) {
    return this.camera.position.x - range_x / 2;
  };

  Engine.prototype.camera_x_max = function(range_x) {
    return this.camera.position.x + range_x / 2;
  };

  Engine.prototype.camera_y_min = function(range_y) {
    return this.camera.position.y - range_y / 2;
  };

  Engine.prototype.camera_y_max = function(range_y) {
    return this.camera.position.y + range_y / 2;
  };

  Engine.prototype.load = function() {
    var loader, model, _i, _len, _ref, _results;
    this.geometries = {};
    loader = new THREE.JSONLoader();
    _ref = this.models;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      model = _ref[_i];
      _results.push(this.loadModel(loader, model));
    }
    return _results;
  };

  Engine.prototype.loadModel = function(loader, model) {
    var _this = this;
    return loader.load(model, function(geometry) {
      geometry.computeVertexNormals();
      _this.geometries[model] = geometry;
      if (_.size(_this.geometries) === _.size(_this.models)) {
        return _this.continueLoad();
      }
    });
  };

  Engine.prototype.continueLoad = function() {
    this.universe = new Universe(this);
    return this.render();
  };

  Engine.prototype.render = function() {
    var _this = this;
    if (this.disposed) {
      return;
    }
    requestAnimationFrame((function() {
      return _this.render();
    }));
    this.universe.checkCollisions();
    this.universe.step();
    this.light.position.set(this.camera.position.x, this.camera.position.y, CAMERA_Z * 10);
    this.renderer.render(this.scene, this.camera);
    if (this.stats) {
      return this.stats.update();
    }
  };

  Engine.prototype.dispose = function() {
    this.universe.unbindKeys();
    return this.disposed = true;
  };

  return Engine;

})();

Universe = (function() {

  Universe.name = 'Universe';

  function Universe(controller) {
    this.controller = controller;
    this.keyup = __bind(this.keyup, this);

    this.keydown = __bind(this.keydown, this);

    this.starfield = new Starfield(this.controller);
    this.trails = new TrailsStorage({
      controller: this.controller,
      universe: this
    });
    this.bullets = new BulletsStorage({
      controller: this.controller,
      universe: this
    });
    this.masses = [];
    this.players = [];
    this.buildPlayer();
    this.bindKeys();
  }

  Universe.prototype.buildPlayer = function() {
    var ai, i, _base, _i, _ref, _results;
    this.player = new LocalPlayer({
      controller: this.controller,
      universe: this
    });
    this.players.push(this.player);
    if ((_base = this.controller.config).aiPlayers == null) {
      _base.aiPlayers = 0;
    }
    _results = [];
    for (i = _i = 1, _ref = this.controller.config.aiPlayers; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
      ai = new AiPlayer({
        controller: this.controller,
        universe: this
      });
      _results.push(this.players.push(ai));
    }
    return _results;
  };

  Universe.prototype.bindKeys = function() {
    this.keys = [];
    $(window).bind('keydown', this.keydown);
    return $(window).bind('keyup', this.keyup);
  };

  Universe.prototype.unbindKeys = function() {
    $(window).unbind('keydown', this.keydown);
    return $(window).unbind('keyup', this.keyup);
  };

  Universe.prototype.keydown = function(e) {
    if (this.controller.config.onKeyDown) {
      if (!this.controller.config.onKeyDown(e.which)) {
        return false;
      }
    }
    this.keys.push(e.which);
    return this.keys = _.uniq(this.keys);
  };

  Universe.prototype.keyup = function(e) {
    if (this.controller.config.onKeyUp) {
      this.controller.config.onKeyUp(e.which);
    }
    return this.keys = _.without(this.keys, e.which);
  };

  Universe.prototype.step = function() {
    var mass, player, _i, _j, _len, _len1, _ref, _ref1, _results;
    this.starfield.step();
    _ref = this.masses;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      mass = _ref[_i];
      mass.step();
    }
    _ref1 = this.players;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      player = _ref1[_j];
      _results.push(player.step());
    }
    return _results;
  };

  Universe.prototype.checkCollisions = function() {
    var m1, m2, _i, _j, _len, _len1, _ref, _ref1;
    _ref = this.masses;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      m1 = _ref[_i];
      if (m1.alive) {
        _ref1 = this.masses;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          m2 = _ref1[_j];
          if (m2.alive) {
            if (m1.mass <= m2.mass && m1.overlaps(m2)) {
              m1.handleCollision(m2);
            }
          }
        }
      }
    }
    return true;
  };

  Universe.prototype.anythingOverlaps = function(position, radius) {
    var m1, _i, _len, _ref;
    _ref = this.masses;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      m1 = _ref[_i];
      if (m1.alive && m1.solid) {
        if (m1.overlapsPosition(position, radius)) {
          return m1;
        }
      }
    }
    return false;
  };

  return Universe;

})();

module.exports = Engine;

});
