define(function(require, exports, module){
// Generated by CoffeeScript 1.3.1
var Movable, Turret, TurretBase,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

Movable = require('movable');

TurretBase = (function() {

  TurretBase.name = 'TurretBase';

  function TurretBase(options) {
    this.controller = options.controller;
    this.universe = options.universe;
    this.mesh = this.buildMesh();
    this.position = this.mesh.position = new THREE.Vector3(0, 0, 500);
    if (options.position) {
      this.position.x = this.mesh.position.x = options.position.x;
      this.position.y = this.mesh.position.y = options.position.y;
    }
    this.controller.scene.add(this.mesh);
  }

  TurretBase.prototype.remove = function() {
    return this.controller.scene.remove(this.mesh);
  };

  TurretBase.prototype.buildMesh = function() {
    var geometry, material, _i, _len, _ref;
    material = new THREE.MeshFaceMaterial;
    geometry = this.controller.geometries['models/turret_base.js'];
    _ref = geometry.materials;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      material = _ref[_i];
      material.shading = THREE.FlatShading;
    }
    return new THREE.Mesh(geometry, material);
  };

  return TurretBase;

})();

Turret = (function(_super) {
  var AI_STEP_INTERVAL, FIRE_ANGLE_DIFF_MAX, FIRE_MAX_DISTANCE, ROTATE_ANGLE_DIFF_MAX, TARGETTING_MAX_DISTANCE;

  __extends(Turret, _super);

  Turret.name = 'Turret';

  AI_STEP_INTERVAL = 30;

  ROTATE_ANGLE_DIFF_MAX = Math.PI / 32;

  FIRE_ANGLE_DIFF_MAX = Math.PI / 8;

  FIRE_MAX_DISTANCE = 1000;

  TARGETTING_MAX_DISTANCE = 3000;

  Turret.prototype.radius = 20;

  Turret.prototype.healthRadius = 8;

  Turret.prototype.mass = 50;

  Turret.prototype.maxHealth = 1000;

  function Turret(options) {
    this.base = new TurretBase(options);
    Turret.__super__.constructor.call(this, options);
    this.parent = options.parent;
    this.position.x = options.position.x;
    this.position.y = options.position.y;
    this.aiStepCounter = 0;
    this.bulletDelay = 0;
  }

  Turret.prototype.buildMesh = function() {
    var geometry, material, _i, _len, _ref;
    material = new THREE.MeshFaceMaterial;
    geometry = this.controller.geometries['models/turret.js'];
    _ref = geometry.materials;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      material = _ref[_i];
      material.shading = THREE.FlatShading;
    }
    return new THREE.Mesh(geometry, material);
  };

  Turret.prototype.rotateLeft = function() {
    return this.rotationalVelocity = Math.PI / 64;
  };

  Turret.prototype.rotateRight = function() {
    return this.rotationalVelocity = -Math.PI / 64;
  };

  Turret.prototype.rotateStop = function() {
    return this.rotationalVelocity = 0;
  };

  Turret.prototype.remove = function() {
    Turret.__super__.remove.apply(this, arguments);
    return this.base.remove();
  };

  Turret.prototype.step = function() {
    Turret.__super__.step.apply(this, arguments);
    if (this.aiStepCounter <= 0) {
      this.aiStep();
      this.aiStepCounter = AI_STEP_INTERVAL;
    } else {
      this.aiStepCounter--;
    }
    if (Math.abs(this.rotation - this.angle) > ROTATE_ANGLE_DIFF_MAX) {
      if (this.rotation > this.angle) {
        this.rotateRight();
      } else if (this.rotation < this.angle) {
        this.rotateLeft();
      }
    } else {
      this.rotateStop();
    }
    this.bulletDelay--;
    if (this.shouldFire) {
      this.fire();
    }
    return this.base.position.set(this.position.x, this.position.y, this.position.z);
  };

  Turret.prototype.fire = function() {
    if (this.bulletDelay <= 0) {
      this.universe.bullets.newTurretBullet(this);
      return this.bulletDelay = 150;
    }
  };

  Turret.prototype.aiStep = function() {
    var vector;
    if (!this.target) {
      this.chooseTarget();
    }
    if (this.target) {
      vector = this.target.position.clone().subSelf(this.position);
      this.angle = Math.atan2(vector.y, vector.x);
      return this.shouldFire = Math.abs(this.rotation - this.angle) <= FIRE_ANGLE_DIFF_MAX && vector.length() < FIRE_MAX_DISTANCE;
    } else {
      return this.shouldFire = false;
    }
  };

  Turret.prototype.chooseTarget = function() {
    var player, vector, _i, _len, _ref, _results;
    _ref = this.universe.players;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      player = _ref[_i];
      if (player !== this.parent && player.ship) {
        vector = player.ship.position.clone().subSelf(this.position);
        if (vector.length() < TARGETTING_MAX_DISTANCE) {
          this.target = player.ship;
          break;
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  return Turret;

})(Movable);

module.exports = Turret;

});
