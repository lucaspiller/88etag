define(function(require, exports, module){
// Generated by CoffeeScript 1.3.1
var HealthBall, Movable;

HealthBall = require('healthball');

Movable = (function() {

  Movable.name = 'Movable';

  Movable.prototype.COEF_OF_RESTITUTION = 0.75;

  Movable.prototype.maxHealth = 100;

  Movable.prototype.healthRadius = 10;

  Movable.prototype.mass = 1;

  Movable.prototype.solid = true;

  Movable.prototype.radius = 10;

  Movable.prototype.rotationalVelocity = 0;

  Movable.prototype.alive = true;

  function Movable(options) {
    this.controller = options.controller;
    this.universe = options.universe;
    this.mesh = this.buildMesh();
    this.mesh.rotateAboutWorldAxis(THREE.AxisZ, 0.001);
    this.controller.scene.add(this.mesh);
    this.velocity = this.mesh.velocity = new THREE.Vector3(0, 0, 0);
    this.position = this.mesh.position = new THREE.Vector3(0, 0, 500);
    this.rotation = 0;
    this.health = this.maxHealth;
    this.universe.masses.push(this);
    if (this.solid) {
      this.healthBall = new HealthBall({
        controller: this.controller,
        position: this.position,
        maxHealth: this.maxHealth,
        radius: this.healthRadius
      });
    }
  }

  Movable.prototype.buildMesh = function() {
    var geometry, material;
    geometry = new THREE.CubeGeometry(10, 10, 10);
    material = new THREE.MeshLambertMaterial({
      ambient: 0xFF0000,
      color: 0xFF0000
    });
    return new THREE.Mesh(geometry, material);
  };

  Movable.prototype.explode = function() {
    return this.remove();
  };

  Movable.prototype.remove = function() {
    this.controller.scene.remove(this.mesh);
    this.universe.masses = _.without(this.universe.masses, this);
    if (this.solid) {
      return this.healthBall.remove();
    }
  };

  Movable.prototype.step = function() {
    this.velocity.multiplyScalar(0.99);
    this.position.addSelf(this.velocity);
    if (Math.abs(this.rotationalVelocity) > 0) {
      this.mesh.rotateAboutWorldAxis(THREE.AxisZ, this.rotationalVelocity);
      this.rotation = (this.rotation + this.rotationalVelocity) % (Math.PI * 2);
    }
    if (this.solid) {
      return this.healthBall.update(this.position, this.health);
    }
  };

  Movable.prototype.overlaps = function(other) {
    if (other === this) {
      return false;
    }
    return this.overlapsPosition(other.position, other.radius);
  };

  Movable.prototype.overlapsPosition = function(position, radius) {
    var diff, max, x, y;
    x = this.position.x - position.x;
    y = this.position.y - position.y;
    max = radius + this.radius;
    if (x < max && y < max) {
      diff = Math.sqrt(x * x + y * y);
      return diff <= max;
    } else {
      return false;
    }
  };

  Movable.prototype.handleCollision = function(other) {
    var m1, m2, oldVelocity, times, v1i, v2i;
    if (!(this.solid && other.solid)) {
      return;
    }
    this.position.subSelf(this.velocity);
    other.position.subSelf(other.velocity);
    v1i = this.velocity;
    v2i = other.velocity;
    m1 = this.mass;
    m2 = other.mass;
    this.velocity = v1i.clone().multiplyScalar((m1 - m2) / (m2 + m1)).addSelf(v2i.clone().multiplyScalar((2 * m2) / (m2 + m1))).multiplyScalar(this.COEF_OF_RESTITUTION);
    other.velocity = v1i.clone().multiplyScalar((2 * m1) / (m2 + m1)).addSelf(v2i.clone().multiplyScalar((m2 - m1) / (m2 + m1))).multiplyScalar(this.COEF_OF_RESTITUTION);
    if (this.velocity.length() === 0 && other.velocity.length() === 0) {
      this.velocity = this.position.clone().subSelf(other.position).normalize();
    }
    times = 0;
    if (this.overlaps(other)) {
      oldVelocity = this.velocity.clone();
      while (this.overlaps(other)) {
        times += 1;
        this.position.addSelf(this.velocity);
        other.position.addSelf(other.velocity);
        if (times === 100) {
          this.velocity.x = Math.random() - 0.5;
          this.velocity.y = Math.random() - 0.5;
        }
      }
      return this.velocity = oldVelocity;
    }
  };

  return Movable;

})();

module.exports = Movable;

});
